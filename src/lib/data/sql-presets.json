{
  "presets": [
    {
      "id": "1",
      "title": "Most Called Queries",
      "description": "Shows top 10 most frequently called queries with execution time and I/O stats",
      "sql": "SELECT query, (interval '1 millisecond' * total_exec_time)::text AS total_exec_time, to_char((total_exec_time/sum(total_exec_time) OVER()) * 100, 'FM90D0') || '%' AS prop_exec_time, to_char(calls, 'FM999G999G990') AS ncalls, (interval '1 millisecond' * (blk_read_time + blk_write_time))::text AS sync_io_time FROM pg_stat_statements ORDER BY calls DESC LIMIT 10"
    },
    {
      "id": "2",
      "title": "Exclusive Locks",
      "description": "Shows queries holding exclusive locks and their duration",
      "sql": "SELECT pg_stat_activity.pid, COALESCE(pg_class.relname, 'null') AS relname, COALESCE(pg_locks.transactionid::text, 'null') AS transactionid, pg_locks.granted, pg_stat_activity.query, age(now(), pg_stat_activity.query_start)::text AS age FROM pg_stat_activity, pg_locks LEFT OUTER JOIN pg_class ON (pg_locks.relation = pg_class.oid) WHERE pg_stat_activity.query <> '<insufficient privilege>' AND pg_locks.pid = pg_stat_activity.pid AND pg_locks.mode = 'ExclusiveLock' ORDER BY query_start"
    },
    {
      "id": "3",
      "title": "Cache Hit Rates",
      "description": "Shows cache hit rates for indexes and tables",
      "sql": "SELECT 'index hit rate' AS name, (sum(idx_blks_hit)) / nullif(sum(idx_blks_hit + idx_blks_read),0) AS ratio FROM pg_statio_user_indexes UNION ALL SELECT 'table hit rate' AS name, sum(heap_blks_hit) / nullif(sum(heap_blks_hit) + sum(heap_blks_read),0) AS ratio FROM pg_statio_user_tables"
    },
    {
      "id": "4",
      "title": "Blocking Queries",
      "description": "Shows queries that are blocking other queries",
      "sql": "SELECT bl.pid AS blocked_pid, ka.query AS blocking_statement, age(now(), ka.query_start)::text AS blocking_duration, kl.pid AS blocking_pid, a.query AS blocked_statement, age(now(), a.query_start)::text AS blocked_duration FROM pg_catalog.pg_locks bl JOIN pg_catalog.pg_stat_activity a ON bl.pid = a.pid JOIN pg_catalog.pg_locks kl JOIN pg_catalog.pg_stat_activity ka ON kl.pid = ka.pid ON bl.transactionid = kl.transactionid AND bl.pid != kl.pid WHERE NOT bl.granted"
    },
    {
      "id": "5",
      "title": "Index Usage Stats",
      "description": "Shows how often indexes are used for each table",
      "sql": "SELECT schemaname || '.' || relname AS name, CASE WHEN idx_scan IS NULL THEN 'Insufficient data' WHEN idx_scan = 0 THEN 'Insufficient data' ELSE ROUND(100.0 * idx_scan / (seq_scan + idx_scan), 1) || '%' END percent_of_times_index_used, n_live_tup rows_in_table FROM pg_stat_user_tables WHERE NOT schemaname LIKE ANY(ARRAY['pg_catalog', 'information_schema']) ORDER BY CASE WHEN idx_scan is null then 1 WHEN idx_scan = 0 then 1 ELSE 0 END, n_live_tup DESC"
    },
    {
      "id": "6",
      "title": "Unused Indexes",
      "description": "Shows potentially unused indexes that might be candidates for removal",
      "sql": "SELECT schemaname || '.' || relname AS table, indexrelname AS index, pg_size_pretty(pg_relation_size(i.indexrelid)) AS index_size, idx_scan as index_scans FROM pg_stat_user_indexes ui JOIN pg_index i ON ui.indexrelid = i.indexrelid WHERE NOT indisunique AND idx_scan < 50 AND pg_relation_size(relid) > 5 * 8192 AND NOT schemaname LIKE ANY(ARRAY['pg_catalog', 'information_schema']) ORDER BY pg_relation_size(i.indexrelid) / nullif(idx_scan, 0) DESC NULLS FIRST, pg_relation_size(i.indexrelid) DESC"
    },
    {
      "id": "7",
      "title": "Role Connections",
      "description": "Shows active connections per role and their limits",
      "sql": "SELECT rolname, (SELECT count(*) FROM pg_stat_activity WHERE pg_roles.rolname = pg_stat_activity.usename) AS active_connections, CASE WHEN rolconnlimit = -1 THEN current_setting('max_connections')::int8 ELSE rolconnlimit END AS connection_limit FROM pg_roles ORDER BY 2 DESC"
    },
    {
      "id": "8",
      "title": "Table and Index Bloat",
      "description": "Shows tables and indexes with potential bloat",
      "sql": "WITH constants AS (SELECT current_setting('block_size')::numeric AS bs, 23 AS hdr, 4 AS ma), bloat_info AS (SELECT ma,bs,schemaname,tablename, (datawidth+(hdr+ma-(case when hdr%ma=0 THEN ma ELSE hdr%ma END)))::numeric AS datahdr, (maxfracsum*(nullhdr+ma-(case when nullhdr%ma=0 THEN ma ELSE nullhdr%ma END))) AS nullhdr2 FROM (SELECT schemaname, tablename, hdr, ma, bs, SUM((1-null_frac)*avg_width) AS datawidth, MAX(null_frac) AS maxfracsum, hdr+( SELECT 1+count(*)/8 FROM pg_stats s2 WHERE null_frac<>0 AND s2.schemaname = s.schemaname AND s2.tablename = s.tablename) AS nullhdr FROM pg_stats s, constants GROUP BY 1,2,3,4,5) AS foo), table_bloat AS (SELECT schemaname, tablename, cc.relpages, bs, CEIL((cc.reltuples*((datahdr+ma-(CASE WHEN datahdr%ma=0 THEN ma ELSE datahdr%ma END))+nullhdr2+4))/(bs-20::float)) AS otta FROM bloat_info JOIN pg_class cc ON cc.relname = bloat_info.tablename JOIN pg_namespace nn ON cc.relnamespace = nn.oid AND nn.nspname = bloat_info.schemaname AND nn.nspname <> 'information_schema'), index_bloat AS (SELECT schemaname, tablename, bs, COALESCE(c2.relname,'?') AS iname, COALESCE(c2.reltuples,0) AS ituples, COALESCE(c2.relpages,0) AS ipages, COALESCE(CEIL((c2.reltuples*(datahdr-12))/(bs-20::float)),0) AS iotta FROM bloat_info JOIN pg_class cc ON cc.relname = bloat_info.tablename JOIN pg_namespace nn ON cc.relnamespace = nn.oid AND nn.nspname = bloat_info.schemaname AND nn.nspname <> 'information_schema' JOIN pg_index i ON indrelid = cc.oid JOIN pg_class c2 ON c2.oid = i.indexrelid) SELECT type, schemaname, object_name, bloat, pg_size_pretty(raw_waste) as waste FROM (SELECT 'table' as type, schemaname, tablename as object_name, ROUND(CASE WHEN otta=0 THEN 0.0 ELSE table_bloat.relpages/otta::numeric END,1) AS bloat, CASE WHEN relpages < otta THEN '0' ELSE (bs*(table_bloat.relpages-otta)::bigint)::bigint END AS raw_waste FROM table_bloat UNION SELECT 'index' as type, schemaname, tablename || '::' || iname as object_name, ROUND(CASE WHEN iotta=0 OR ipages=0 THEN 0.0 ELSE ipages/iotta::numeric END,1) AS bloat, CASE WHEN ipages < iotta THEN '0' ELSE (bs*(ipages-iotta))::bigint END AS raw_waste FROM index_bloat) bloat_summary WHERE NOT schemaname LIKE ANY(ARRAY['pg_catalog', 'information_schema']) ORDER BY raw_waste DESC, bloat DESC"
    },
    {
      "id": "9",
      "title": "Query Outliers",
      "description": "Shows queries that have taken the most time to execute",
      "sql": "SELECT (interval '1 millisecond' * total_exec_time)::text AS total_exec_time, to_char((total_exec_time/sum(total_exec_time) OVER()) * 100, 'FM90D0') || '%' AS prop_exec_time, to_char(calls, 'FM999G999G999G990') AS ncalls, (interval '1 millisecond' * (blk_read_time + blk_write_time))::text AS sync_io_time, query FROM pg_stat_statements WHERE userid = (SELECT usesysid FROM pg_user WHERE usename = current_user LIMIT 1) ORDER BY total_exec_time DESC LIMIT 10"
    },
    {
      "id": "10",
      "title": "Index Sizes",
      "description": "Shows the size of all indexes in the database",
      "sql": "SELECT n.nspname || '.' || c.relname AS name, pg_size_pretty(sum(c.relpages::bigint*8192)::bigint) AS size FROM pg_class c LEFT JOIN pg_namespace n ON (n.oid = c.relnamespace) WHERE NOT n.nspname LIKE ANY(ARRAY['pg_catalog', 'information_schema']) AND c.relkind = 'i' GROUP BY n.nspname, c.relname ORDER BY sum(c.relpages) DESC"
    },
    {
      "id": "11",
      "title": "Table Record Counts",
      "description": "Shows estimated record counts for all tables",
      "sql": "SELECT schemaname AS schema, relname AS name, n_live_tup AS estimated_count FROM pg_stat_user_tables WHERE NOT schemaname LIKE ANY(ARRAY['pg_catalog', 'information_schema']) ORDER BY n_live_tup DESC"
    },
    {
      "id": "12",
      "title": "Replication Slots",
      "description": "Shows information about replication slots and their lag",
      "sql": "SELECT s.slot_name, s.active, COALESCE(r.state, 'N/A') as state, CASE WHEN r.client_addr IS NULL THEN 'N/A' ELSE r.client_addr::text END replication_client_address, GREATEST(0, ROUND((redo_lsn-restart_lsn)/1024/1024/1024, 2)) as replication_lag_gb FROM pg_control_checkpoint(), pg_replication_slots s LEFT JOIN pg_stat_replication r ON (r.pid = s.active_pid)"
    },
    {
      "id": "13",
      "title": "Total Table Sizes",
      "description": "Shows the total size of tables including indexes and toast data",
      "sql": "SELECT n.nspname AS schema, c.relname AS name, pg_size_pretty(pg_total_relation_size(c.oid)) AS size FROM pg_class c LEFT JOIN pg_namespace n ON (n.oid = c.relnamespace) WHERE NOT n.nspname LIKE ANY(ARRAY['pg_catalog', 'information_schema']) AND c.relkind = 'r' ORDER BY pg_total_relation_size(c.oid) DESC"
    },
    {
      "id": "14",
      "title": "Sequential Scans",
      "description": "Shows tables that are being sequentially scanned (potential missing indexes)",
      "sql": "SELECT schemaname || '.' || relname AS name, seq_scan as count FROM pg_stat_user_tables WHERE NOT schemaname LIKE ANY(ARRAY['pg_catalog', 'information_schema']) ORDER BY seq_scan DESC"
    },
    {
      "id": "15",
      "title": "Role Configurations",
      "description": "Shows custom configurations set for database roles",
      "sql": "SELECT rolname as role_name, array_to_string(rolconfig, ',', '*') as custom_config FROM pg_roles WHERE rolconfig is not null"
    },
    {
      "id": "16",
      "title": "Long Running Queries",
      "description": "Shows currently running queries that have been running for a long time",
      "sql": "SELECT pid, age(clock_timestamp(), query_start) AS duration, query FROM pg_stat_activity WHERE query != '<IDLE>' AND query NOT ILIKE '%pg_stat_activity%' AND state != 'idle' AND state = 'active' ORDER BY duration DESC"
    }
  ],
  "schema": [
    {
      "id": "17",
      "title": "Schema: tables",
      "description": "Shows CREATE TABLE statements for all tables in the database",
      "sql": "SELECT\n    'CREATE TABLE ' || quote_ident(n.nspname) || '.' || quote_ident(c.relname) || ' (\n' ||\n    array_to_string(\n        array_agg(\n            '    ' || quote_ident(a.attname) || ' ' ||\n            pg_catalog.format_type(a.atttypid, a.atttypmod) ||\n            CASE\n                WHEN a.attnotnull THEN ' NOT NULL'\n                ELSE ''\n            END ||\n            CASE\n                WHEN a.atthasdef THEN ' DEFAULT ' || pg_get_expr(d.adbin, d.adrelid)\n                ELSE ''\n            END\n        ),\n        ',\n'\n    ) ||\n    '\n);' AS create_table\nFROM\n    pg_class c\n    JOIN pg_namespace n ON c.relnamespace = n.oid\n    JOIN pg_attribute a ON c.oid = a.attrelid\n    LEFT JOIN pg_attrdef d ON (a.attrelid, a.attnum) = (d.adrelid, d.adnum)\nWHERE\n    c.relkind = 'r'\n    AND n.nspname NOT IN ('pg_catalog', 'information_schema')\n    AND a.attnum > 0\n    AND NOT a.attisdropped\nGROUP BY\n    n.nspname, c.relname\nORDER BY\n    n.nspname, c.relname;"
    },
    {
      "id": "18",
      "title": "Schema: indexes",
      "description": "Shows CREATE INDEX statements for all indexes in the database",
      "sql": "SELECT pg_get_indexdef(i.indexrelid) || ';' AS index_def FROM pg_index i JOIN pg_class c ON c.oid = i.indrelid JOIN pg_namespace n ON n.oid = c.relnamespace WHERE n.nspname NOT IN ('pg_catalog', 'information_schema', 'pg_toast');"
    },
    {
      "id": "19",
      "title": "Schema: functions",
      "description": "Shows CREATE FUNCTION statements for all user-defined functions",
      "sql": "SELECT pg_get_functiondef(p.oid) || ';' AS create_function FROM pg_proc p JOIN pg_namespace n ON n.oid = p.pronamespace WHERE n.nspname NOT IN ('pg_catalog', 'information_schema') AND p.prokind = 'f';"
    },
    {
      "id": "20",
      "title": "Schema: views",
      "description": "Shows CREATE VIEW statements for all views in the database",
      "sql": "SELECT 'CREATE OR REPLACE VIEW ' || quote_ident(n.nspname) || '.' || quote_ident(c.relname) || ' AS ' || pg_get_viewdef(c.oid, true) || ';' AS create_view FROM pg_class c JOIN pg_namespace n ON n.oid = c.relnamespace WHERE c.relkind = 'v' AND n.nspname NOT IN ('pg_catalog', 'information_schema');"
    },
    {
      "id": "21",
      "title": "Schema: sequences",
      "description": "Shows CREATE SEQUENCE statements for all sequences in the database",
      "sql": "SELECT 'CREATE SEQUENCE ' || quote_ident(n.nspname) || '.' || quote_ident(s.relname) || ';' AS create_sequence FROM pg_class s JOIN pg_namespace n ON n.oid = s.relnamespace WHERE s.relkind = 'S' AND n.nspname NOT IN ('pg_catalog', 'information_schema');"
    },
    {
      "id": "22",
      "title": "Schema: constraints",
      "description": "Shows ALTER TABLE statements for all table constraints in the database",
      "sql": "SELECT 'ALTER TABLE ' || quote_ident(n.nspname) || '.' || quote_ident(t.relname) || ' ADD CONSTRAINT ' || quote_ident(c.conname) || ' ' || pg_get_constraintdef(c.oid) || ';' AS constraint_def FROM pg_constraint c JOIN pg_class t ON c.conrelid = t.oid JOIN pg_namespace n ON n.oid = t.relnamespace WHERE n.nspname NOT IN ('pg_catalog', 'information_schema', 'pg_toast');"
    },
    {
      "id": "23",
      "title": "Schema: triggers",
      "description": "Shows CREATE TRIGGER statements for all triggers in the database",
      "sql": "SELECT\n    'CREATE TRIGGER ' || quote_ident(t.tgname) ||\n    ' ' || pg_get_triggerdef(t.oid) || ';' AS create_trigger\nFROM\n    pg_trigger t\n    JOIN pg_class c ON t.tgrelid = c.oid\n    JOIN pg_namespace n ON c.relnamespace = n.oid\nWHERE\n    NOT t.tgisinternal\n    AND n.nspname NOT IN ('pg_catalog', 'information_schema')\nORDER BY\n    n.nspname, c.relname, t.tgname;"
    },
    {
      "id": "24",
      "title": "Schema: rules",
      "description": "Shows CREATE RULE statements for all rules in the database",
      "sql": "SELECT\n    pg_get_ruledef(r.oid, true) || ';' AS create_rule\nFROM\n    pg_rewrite r\n    JOIN pg_class c ON r.ev_class = c.oid\n    JOIN pg_namespace n ON c.relnamespace = n.oid\nWHERE\n    n.nspname NOT IN ('pg_catalog', 'information_schema')\n    AND r.rulename <> '_RETURN'\nORDER BY\n    n.nspname, c.relname, r.rulename;"
    },
    {
      "id": "25",
      "title": "Schema: domains",
      "description": "Shows CREATE DOMAIN statements for all domains in the database",
      "sql": "SELECT\n    'CREATE DOMAIN ' || quote_ident(n.nspname) || '.' || quote_ident(t.typname) ||\n    ' AS ' || pg_catalog.format_type(t.typbasetype, t.typtypmod) ||\n    (CASE WHEN t.typnotnull THEN ' NOT NULL' ELSE '' END) ||\n    (CASE WHEN t.typdefault IS NOT NULL THEN ' DEFAULT ' || t.typdefault ELSE '' END) ||\n    (CASE WHEN c.oid IS NOT NULL THEN ' ' ||\n        pg_catalog.pg_get_constraintdef(c.oid, true) ELSE '' END) || ';' AS create_domain\nFROM\n    pg_type t\n    JOIN pg_namespace n ON n.oid = t.typnamespace\n    LEFT JOIN pg_constraint c ON c.contypid = t.oid\nWHERE\n    t.typtype = 'd' AND\n    n.nspname NOT IN ('pg_catalog', 'information_schema')\nORDER BY\n    n.nspname, t.typname;"
    },
    {
      "id": "26",
      "title": "Schema: collations",
      "description": "Shows CREATE COLLATION statements for all collations in the database",
      "sql": "SELECT\n    'CREATE COLLATION ' || quote_ident(n.nspname) || '.' || quote_ident(c.collname) ||\n    ' (LC_COLLATE = ' || quote_literal(c.collcollate) ||\n    ', LC_CTYPE = ' || quote_literal(c.collctype) ||\n    CASE WHEN c.collprovider = 'd' THEN ', PROVIDER = icu' ELSE ', PROVIDER = libc' END ||\n    CASE WHEN c.collversion IS NOT NULL THEN ', VERSION = ' || quote_literal(c.collversion) ELSE '' END ||\n    ');' AS create_collation\nFROM\n    pg_collation c\n    JOIN pg_namespace n ON n.oid = c.collnamespace\nWHERE\n    n.nspname NOT IN ('pg_catalog', 'information_schema')\nORDER BY\n    n.nspname, c.collname;"
    },
    {
      "id": "27",
      "title": "Schema: operators",
      "description": "Shows CREATE OPERATOR statements for all operators in the database",
      "sql": "SELECT\n    'CREATE OPERATOR ' || quote_ident(n.nspname) || '.' || quote_ident(o.oprname) ||\n    ' (' ||\n    'PROCEDURE = ' || (SELECT quote_ident(n2.nspname) || '.' || quote_ident(p.proname)\n                       FROM pg_proc p\n                       JOIN pg_namespace n2 ON p.pronamespace = n2.oid\n                       WHERE p.oid = o.oprcode) ||\n    CASE WHEN o.oprleft <> 0 THEN ', LEFTARG = ' || pg_catalog.format_type(o.oprleft, NULL) ELSE '' END ||\n    CASE WHEN o.oprright <> 0 THEN ', RIGHTARG = ' || pg_catalog.format_type(o.oprright, NULL) ELSE '' END ||\n    ');' AS create_operator\nFROM\n    pg_operator o\n    JOIN pg_namespace n ON o.oprnamespace = n.oid\nWHERE\n    n.nspname NOT IN ('pg_catalog', 'information_schema')\nORDER BY\n    n.nspname, o.oprname;"
    },
    {
      "id": "28",
      "title": "Schema: text search configurations",
      "description": "Shows CREATE TEXT SEARCH CONFIGURATION statements for all text search configurations in the database",
      "sql": "SELECT\n    'CREATE TEXT SEARCH CONFIGURATION ' || quote_ident(n.nspname) || '.' || quote_ident(c.cfgname) ||\n    ' (PARSER = ' || quote_ident(np.nspname) || '.' || quote_ident(p.prsname) || ');' AS create_ts_config\nFROM\n    pg_ts_config c\n    JOIN pg_namespace n ON c.cfgnamespace = n.oid\n    JOIN pg_ts_parser p ON c.cfgparser = p.oid\n    JOIN pg_namespace np ON p.prsnamespace = np.oid\nWHERE\n    n.nspname NOT IN ('pg_catalog', 'information_schema')\nORDER BY\n    n.nspname, c.cfgname;"
    },
    {
      "id": "29",
      "title": "Schema: search configuration mappings",
      "description": "Shows ALTER TEXT SEARCH CONFIGURATION statements for all text search configuration mappings in the database",
      "sql": "SELECT\n    'ALTER TEXT SEARCH CONFIGURATION ' || quote_ident(n.nspname) || '.' || quote_ident(c.cfgname) ||\n    ' ADD MAPPING FOR ' || tok_aliases ||\n    ' WITH ' || dicts || ';' AS alter_ts_config\nFROM (\n    SELECT\n        n.nspname,\n        c.cfgname,\n        ARRAY_TO_STRING(ARRAY_AGG(DISTINCT tt.alias), ', ') AS tok_aliases,\n        ARRAY_TO_STRING(ARRAY_AGG(DISTINCT quote_ident(nd.nspname) || '.' || quote_ident(d.dictname)), ', ') AS dicts\n    FROM\n        pg_ts_config c\n        JOIN pg_namespace n ON c.cfgnamespace = n.oid\n        JOIN pg_ts_config_map m ON m.mapcfg = c.oid\n        JOIN pg_ts_dict d ON m.mapdict = d.oid\n        JOIN pg_namespace nd ON d.dictnamespace = nd.oid\n        JOIN LATERAL pg_ts_token_type(c.cfgparser) tt ON tt.tokid = m.maptokentype\n    WHERE\n        n.nspname NOT IN ('pg_catalog', 'information_schema')\n    GROUP BY\n        n.nspname, c.cfgname, m.maptokentype\n) sub\nORDER BY\n    nspname, cfgname;"
    },
    {
      "id": "30",
      "title": "Schema: text search dictionaries",
      "description": "Shows CREATE TEXT SEARCH DICTIONARY statements for all text search dictionaries in the database",
      "sql": "SELECT\n    'CREATE TEXT SEARCH DICTIONARY ' || quote_ident(n.nspname) || '.' || quote_ident(d.dictname) ||\n    ' (' ||\n    'TEMPLATE = ' || quote_ident(nt.nspname) || '.' || quote_ident(t.tmplname) ||\n    CASE WHEN d.dictinitoption IS NOT NULL THEN\n        ', ' || d.dictinitoption\n    ELSE '' END ||\n    ');' AS create_ts_dict\nFROM\n    pg_ts_dict d\n    JOIN pg_namespace n ON d.dictnamespace = n.oid\n    JOIN pg_ts_template t ON d.dicttemplate = t.oid\n    JOIN pg_namespace nt ON t.tmplnamespace = nt.oid\nWHERE\n    n.nspname NOT IN ('pg_catalog', 'information_schema')\nORDER BY\n    n.nspname, d.dictname;"
    },
    {
      "id": "31",
      "title": "Schema: schemas",
      "description": "Shows CREATE SCHEMA statements for all schemas in the database",
      "sql": "SELECT nspname AS schema_name FROM pg_namespace WHERE nspname NOT IN ('pg_catalog', 'information_schema', 'pg_toast') AND nspname NOT LIKE 'pg_temp_%' AND nspname NOT LIKE 'pg_toast_temp_%';"
    },
    {
      "id": "32",
      "title": "Schema: composite types",
      "description": "Shows CREATE TYPE statements for composite types",
      "sql": "SELECT\n    'CREATE TYPE ' || quote_ident(n.nspname) || '.' || quote_ident(t.typname) ||\n    ' AS (' ||\n    string_agg(\n        quote_ident(a.attname) || ' ' || format_type(a.atttypid, a.atttypmod),\n        ', '\n        ORDER BY a.attnum\n    ) || ');' AS create_type\nFROM\n    pg_type t\n    JOIN pg_namespace n ON n.oid = t.typnamespace\n    JOIN pg_class c ON c.oid = t.typrelid\n    JOIN pg_attribute a ON a.attrelid = c.oid\nWHERE\n    t.typtype = 'c'\n    AND n.nspname NOT IN ('pg_catalog', 'information_schema')\n    AND a.attnum > 0 AND NOT a.attisdropped\nGROUP BY\n    n.nspname, t.typname;"
    },
    {
      "id": "33",
      "title": "Schema: enumerated types",
      "description": "Shows CREATE TYPE statements for enumerated types",
      "sql": "SELECT\n    'CREATE TYPE ' || quote_ident(n.nspname) || '.' || quote_ident(t.typname) ||\n    ' AS ENUM (' ||\n    string_agg(quote_literal(e.enumlabel), ', ' ORDER BY e.enumsortorder) ||\n    ');' AS create_enum\nFROM\n    pg_type t\n    JOIN pg_namespace n ON n.oid = t.typnamespace\n    JOIN pg_enum e ON t.oid = e.enumtypid\nWHERE\n    t.typtype = 'e'\n    AND n.nspname NOT IN ('pg_catalog', 'information_schema')\nGROUP BY\n    n.nspname, t.typname;"
    },
    {
      "id": "34",
      "title": "Schema: materialized views",
      "description": "Shows CREATE MATERIALIZED VIEW statements",
      "sql": "SELECT\n    'CREATE MATERIALIZED VIEW ' || quote_ident(n.nspname) || '.' || quote_ident(c.relname) ||\n    ' AS ' || pg_get_viewdef(c.oid, true) ||\n    ';' AS create_mat_view\nFROM\n    pg_class c\n    JOIN pg_namespace n ON n.oid = c.relnamespace\nWHERE\n    c.relkind = 'm'\n    AND n.nspname NOT IN ('pg_catalog', 'information_schema');"
    },
    {
      "id": "35",
      "title": "Schema: text search parsers",
      "description": "Shows CREATE TEXT SEARCH PARSER statements",
      "sql": "SELECT\n    'CREATE TEXT SEARCH PARSER ' || quote_ident(n.nspname) || '.' || quote_ident(p.prsname) ||\n    ' (' ||\n    'START = ' || quote_ident(ns.nspname) || '.' || p.prsstart::text || ', ' ||\n    'GETTOKEN = ' || quote_ident(ng.nspname) || '.' || p.prstoken::text || ', ' ||\n    'END = ' || quote_ident(ne.nspname) || '.' || p.prsend::text || ', ' ||\n    'LEXTYPES = ' || quote_ident(nl.nspname) || '.' || p.prslextype::text ||\n    CASE WHEN p.prsheadline IS NOT NULL THEN ', HEADLINE = ' || quote_ident(nh.nspname) || '.' || p.prsheadline::text ELSE '' END ||\n    ');' AS create_ts_parser\nFROM\n    pg_ts_parser p\n    JOIN pg_namespace n ON p.prsnamespace = n.oid\n    JOIN pg_proc ps ON p.prsstart = ps.oid\n    JOIN pg_namespace ns ON ps.pronamespace = ns.oid\n    JOIN pg_proc pg ON p.prstoken = pg.oid\n    JOIN pg_namespace ng ON pg.pronamespace = ng.oid\n    JOIN pg_proc pe ON p.prsend = pe.oid\n    JOIN pg_namespace ne ON pe.pronamespace = ne.oid\n    JOIN pg_proc pl ON p.prslextype = pl.oid\n    JOIN pg_namespace nl ON pl.pronamespace = nl.oid\n    LEFT JOIN pg_proc ph ON p.prsheadline = ph.oid\n    LEFT JOIN pg_namespace nh ON ph.pronamespace = nh.oid\nWHERE\n    n.nspname NOT IN ('pg_catalog', 'information_schema');"
    },
    {
      "id": "36",
      "title": "Schema: text search templates",
      "description": "Shows CREATE TEXT SEARCH TEMPLATE statements",
      "sql": "SELECT\n    'CREATE TEXT SEARCH TEMPLATE ' || quote_ident(n.nspname) || '.' || quote_ident(t.tmplname) ||\n    ' (' ||\n    CASE WHEN t.tmplinit IS NOT NULL THEN 'INIT = ' || quote_ident(ni.nspname) || '.' || t.tmplinit::text || ', ' ELSE '' END ||\n    'LEXIZE = ' || quote_ident(nl.nspname) || '.' || t.tmpllexize::text ||\n    ');' AS create_ts_template\nFROM\n    pg_ts_template t\n    JOIN pg_namespace n ON t.tmplnamespace = n.oid\n    LEFT JOIN pg_proc pi ON t.tmplinit = pi.oid\n    LEFT JOIN pg_namespace ni ON pi.pronamespace = ni.oid\n    JOIN pg_proc pl ON t.tmpllexize = pl.oid\n    JOIN pg_namespace nl ON pl.pronamespace = nl.oid\nWHERE\n    n.nspname NOT IN ('pg_catalog', 'information_schema');"
    },
    {
      "id": "37",
      "title": "Schema: foreign data wrappers",
      "description": "Shows CREATE FOREIGN DATA WRAPPER statements",
      "sql": "SELECT\n    'CREATE FOREIGN DATA WRAPPER ' || quote_ident(fdw.fdwname) ||\n    CASE WHEN fdw.fdwhandler <> 0 THEN ' HANDLER ' || pg_get_function_identity_arguments(fdw.fdwhandler) ELSE '' END ||\n    CASE WHEN fdw.fdwvalidator <> 0 THEN ' VALIDATOR ' || pg_get_function_identity_arguments(fdw.fdwvalidator) ELSE '' END ||\n    ';' AS create_fdw\nFROM\n    pg_foreign_data_wrapper fdw\nWHERE\n    fdw.fdwname NOT IN ('postgres_fdw', 'file_fdw');"
    },
    {
      "id": "38",
      "title": "Schema: foreign servers",
      "description": "Shows CREATE SERVER statements",
      "sql": "SELECT\n    'CREATE SERVER ' || quote_ident(srv.srvname) ||\n    ' FOREIGN DATA WRAPPER ' || quote_ident(fdw.fdwname) ||\n    CASE WHEN srv.srvtype IS NOT NULL THEN ' TYPE ' || quote_literal(srv.srvtype) ELSE '' END ||\n    CASE WHEN srv.srvversion IS NOT NULL THEN ' VERSION ' || quote_literal(srv.srvversion) ELSE '' END ||\n    (CASE WHEN srv.srvoptions IS NOT NULL THEN ' OPTIONS (' || array_to_string(srv.srvoptions, ', ') || ')' ELSE '' END) ||\n    ';' AS create_server\nFROM\n    pg_foreign_server srv\n    JOIN pg_foreign_data_wrapper fdw ON srv.srvfdw = fdw.oid;"
    },
    {
      "id": "39",
      "title": "Schema: user mappings",
      "description": "Shows CREATE USER MAPPING statements",
      "sql": "SELECT\n    'CREATE USER MAPPING FOR ' || quote_ident(um.usename) ||\n    ' SERVER ' || quote_ident(srv.srvname) ||\n    (CASE WHEN um.umoptions IS NOT NULL THEN ' OPTIONS (' || array_to_string(um.umoptions, ', ') || ')' ELSE '' END) ||\n    ';' AS create_user_mapping\nFROM\n    pg_user_mappings um\n    JOIN pg_foreign_server srv ON um.srvid = srv.oid;"
    },
    {
      "id": "40",
      "title": "Schema: row level security policies",
      "description": "Shows CREATE POLICY statements",
      "sql": "SELECT\n    'CREATE POLICY ' || quote_ident(pol.polname) ||\n    ' ON ' || quote_ident(n.nspname) || '.' || quote_ident(c.relname) ||\n    CASE WHEN pol.polcmd::text != '*' THEN ' FOR ' || pol.polcmd::text ELSE '' END ||\n    CASE WHEN pol.polroles <> '{0}' THEN ' TO ' || array_to_string(array(SELECT quote_ident(rolname) FROM pg_roles WHERE oid = ANY(pol.polroles)), ', ') ELSE '' END ||\n    CASE WHEN pol.polqual IS NOT NULL THEN ' USING (' || pg_get_expr(pol.polqual, pol.polrelid) || ')' ELSE '' END ||\n    CASE WHEN pol.polwithcheck IS NOT NULL THEN ' WITH CHECK (' || pg_get_expr(pol.polwithcheck, pol.polrelid) || ')' ELSE '' END ||\n    ';' AS create_policy\nFROM\n    pg_policy pol\n    JOIN pg_class c ON pol.polrelid = c.oid\n    JOIN pg_namespace n ON c.relnamespace = n.oid\nWHERE\n    n.nspname NOT IN ('pg_catalog', 'information_schema');"
    },
    {
      "id": "41",
      "title": "Schema: publications",
      "description": "Shows CREATE PUBLICATION statements",
      "sql": "SELECT\n    'CREATE PUBLICATION ' || quote_ident(pub.pubname) ||\n    CASE WHEN pub.puballtables THEN ' FOR ALL TABLES' ELSE ' FOR TABLE ' || string_agg(quote_ident(n.nspname) || '.' || quote_ident(c.relname), ', ') END ||\n    ';' AS create_publication\nFROM\n    pg_publication pub\n    LEFT JOIN pg_publication_rel pr ON pub.oid = pr.prpubid\n    LEFT JOIN pg_class c ON pr.prrelid = c.oid\n    LEFT JOIN pg_namespace n ON c.relnamespace = n.oid\nGROUP BY\n    pub.pubname, pub.puballtables;"
    },
    {
      "id": "42",
      "title": "Schema: extensions",
      "description": "Shows CREATE EXTENSION statements",
      "sql": "SELECT\n    'CREATE EXTENSION IF NOT EXISTS ' || quote_ident(ext.extname) ||\n    ' WITH SCHEMA ' || quote_ident(n.nspname) ||\n    CASE WHEN ext.extversion IS NOT NULL THEN ' VERSION ' || quote_literal(ext.extversion) ELSE '' END ||\n    ';' AS create_extension\nFROM\n    pg_extension ext\n    JOIN pg_namespace n ON ext.extnamespace = n.oid\nWHERE\n    ext.extname NOT IN ('plpgsql');"
    },
    {
      "id": "43",
      "title": "Schema: statistics",
      "description": "Shows CREATE STATISTICS statements",
      "sql": "SELECT\n    'CREATE STATISTICS ' || quote_ident(s.stxname) ||\n    ' (' || array_to_string(ARRAY(\n        SELECT (CASE WHEN stxkind[i] = 'd' THEN 'NDISTINCT' WHEN stxkind[i] = 'f' THEN 'DEPENDENCIES' WHEN stxkind[i] = 'm' THEN 'MCV' END)\n        FROM generate_subscripts(s.stxkind, 1) as i\n    ), ', ') || ')' ||\n    ' ON ' || array_to_string(ARRAY_AGG(quote_ident(a.attname)), ', ') ||\n    ' FROM ' || quote_ident(n.nspname) || '.' || quote_ident(c.relname) || ';' AS create_statistics\nFROM\n    pg_statistic_ext s\n    JOIN pg_class c ON s.stxrelid = c.oid\n    JOIN pg_namespace n ON c.relnamespace = n.oid\n    JOIN pg_attribute a ON a.attrelid = c.oid AND a.attnum = ANY(s.stxkeys)\nWHERE\n    n.nspname NOT IN ('pg_catalog', 'information_schema')\nGROUP BY\n    s.stxname, s.stxkind, n.nspname, c.relname;"
    },
    {
      "id": "44",
      "title": "Schema: comments",
      "description": "Shows COMMENT ON statements for tables, views, and materialized views",
      "sql": "SELECT\n    'COMMENT ON TABLE ' || quote_ident(n.nspname) || '.' || quote_ident(c.relname) ||\n    ' IS ' || quote_literal(obj_description(c.oid, 'pg_class')) || ';' AS comment_table\nFROM\n    pg_class c\n    JOIN pg_namespace n ON c.relnamespace = n.oid\nWHERE\n    c.relkind IN ('r', 'v', 'm')\n    AND n.nspname NOT IN ('pg_catalog', 'information_schema')\n    AND obj_description(c.oid, 'pg_class') IS NOT NULL;"
    }
  ]
}